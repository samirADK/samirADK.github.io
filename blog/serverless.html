<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="https://img.icons8.com/ios-filled/50/000000/infinity.png" type="image/png">

    <title>Developing a Secure, Scalable, Serverless OTP Service - Samir Adhikari</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css">
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NQYZ1YTN96"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NQYZ1YTN96');
</script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=Outfit:wght@300;400;500;600;700&family=Montserrat:wght@300;400;500;600;700&display=swap');

        /* Light Theme Variables (Copied from Landing Page) */
        :root {
            --bg-primary: #f8f8f8;
            --bg-secondary: #ffffff;
            --bg-accent: #f0f0f0;
            --text-primary: #222222;
            --text-secondary: #555555;
            --accent-color: #6e56cf;
            --accent-hover: #8a6eff;
            --accent-muted: rgba(110, 86, 207, 0.2);
            --gradient-1: linear-gradient(135deg, #6e56cf 0%, #b86eff 100%);
            --gradient-2: linear-gradient(135deg, #f0f0f0 0%, #ffffff 100%);
            --shadow-sm: 0 5px 15px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 10px 30px rgba(0, 0, 0, 0.2);
            --shadow-glow: 0 0 15px rgba(110, 86, 207, 0.2);
            --card-border: 1px solid #e0e0e0;
            --neon-glow: 0 0 10px rgba(110, 86, 207, 0.3), 0 0 20px rgba(110, 86, 207, 0.1);
            --header-bg: rgba(255, 255, 255, 0.9);
            --switch-bg: #e0e0e0;
            --switch-thumb: #ffffff;
            --switch-icon-color: #6e56cf;
            --footer-divider: #e0e0e0;
            --scrollbar-track: #f0f0f0;
            --scrollbar-thumb: #cccccc;
            --code-bg: #e9e9e9; /* Specific for light theme code blocks */
        }

        /* Dark Theme Variables (Copied from Landing Page) */
        :root[data-theme="dark"] {
            --bg-primary: #0f0f0f;
            --bg-secondary: #161616;
            --bg-accent: #1e1e1e;
            --text-primary: #f8f8f8;
            --text-secondary: #bebebe;
            --accent-color: #6e56cf;
            --accent-hover: #8a6eff;
            --accent-muted: rgba(110, 86, 207, 0.3);
            --gradient-1: linear-gradient(135deg, #6e56cf 0%, #b86eff 100%);
            --gradient-2: linear-gradient(135deg, #1e1e1e 0%, #3b3b3b 100%);
            --shadow-sm: 0 5px 15px rgba(0, 0, 0, 0.2);
            --shadow-md: 0 10px 30px rgba(0, 0, 0, 0.4);
            --shadow-glow: 0 0 15px rgba(110, 86, 207, 0.4);
            --card-border: 1px solid #2a2a2a;
            --neon-glow: 0 0 10px rgba(110, 86, 207, 0.5), 0 0 20px rgba(110, 86, 207, 0.3);
            --header-bg: rgba(15, 15, 15, 0.9);
            --switch-bg: #333333;
            --switch-thumb: #6e56cf;
            --switch-icon-color: #ffffff;
            --footer-divider: #2a2a2a;
            --scrollbar-track: #161616;
            --scrollbar-thumb: #333333;
            --code-bg: #232323; /* Specific for dark theme code blocks */
        }

        /* General Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.7;
            font-family: 'Montserrat', sans-serif;
            overflow-x: hidden;
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        h1, h2, h3, h4, h5 {
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 700;
            color: var(--text-primary); /* Ensure headings also transition color */
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header */
        header {
            background-color: var(--header-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: var(--shadow-sm);
            position: sticky;
            top: 0;
            z-index: 100;
            padding: 0 20px;
            border-bottom: var(--card-border);
            transition: background-color 0.5s ease, border-color 0.5s ease, box-shadow 0.5s ease;
        }

        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
        }

        .logo {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            text-decoration: none;
            display: flex;
            align-items: center;
            transition: color 0.5s ease;
        }

        .logo::before {
            content: "";
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 10px;
            background-color: var(--accent-color);
            border-radius: 50%;
            box-shadow: var(--shadow-glow);
            transition: background-color 0.5s ease, box-shadow 0.5s ease;
        }

        .nav-links {
            display: flex;
            list-style: none;
        }

        .nav-links li {
            margin-left: 40px;
        }

        .nav-links a {
            text-decoration: none;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 16px;
            transition: all 0.3s;
            position: relative;
        }

        .nav-links a::after {
            content: "";
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 0;
            height: 2px;
            background-color: var(--accent-color);
            transition: width 0.3s;
        }

        .nav-links a:hover {
            color: var(--accent-color);
            text-shadow: var(--neon-glow);
        }

        .nav-links a:hover::after {
            width: 100%;
            box-shadow: var(--shadow-glow);
        }

        /* Theme Switch (Copied from Landing Page) */
        .theme-switch-wrapper {
            display: flex;
            align-items: center;
            margin-left: 30px;
            position: relative;
        }

        .theme-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 32px;
        }

        .theme-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--switch-bg);
            transition: .4s;
            border-radius: 34px;
            overflow: hidden;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 4px;
            bottom: 4px;
            background-color: var(--switch-thumb);
            transition: .4s;
            border-radius: 50%;
            z-index: 2;
        }

        .slider .switch-icon {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1;
            color: var(--switch-icon-color);
            transition: opacity 0.3s, transform 0.5s;
        }

        .slider .sun-icon {
            right: 9px;
            opacity: 1;
        }

        .slider .moon-icon {
            left: 7px;
            opacity: 0;
        }

        input:checked + .slider .sun-icon {
            opacity: 0;
        }

        input:checked + .slider .moon-icon {
            opacity: 1;
        }

        input:checked + .slider {
            background-color: var(--accent-color);
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--accent-color);
        }

        input:checked + .slider:before {
            transform: translateX(28px);
            background-color: var(--accent-color); /* Ensure thumb is accent color when checked dark */
        }
        :root[data-theme="dark"] .slider:before { /* Light theme thumb on dark bg */
             /* background-color: #ffffff; /* Default thumb for light mode is white */
        }
        :root[data-theme="dark"] input:checked + .slider:before { /* Dark theme thumb on dark bg, when checked */
            background-color: var(--switch-thumb); /* Uses dark theme switch thumb */
        }


        /* Blog Post Styles */
        .blog-post {
            padding: 80px 0;
        }

        .blog-post-title {
            font-size: 42px;
            margin-bottom: 30px;
            text-align: center;
            color: var(--text-primary);
            transition: color 0.5s ease;
        }

        .blog-post-meta {
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 40px;
            transition: color 0.5s ease;
            flex-wrap: wrap; /* For better responsiveness */
        }

        .blog-post-meta span {
            margin: 5px 15px; /* Adjusted margin for wrapping */
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .blog-post-meta i {
            color: var(--accent-color);
        }

        .blog-post-image {
            max-width: 800px;
            margin: 0 auto 20px; /* Reduced bottom margin */
            border-radius: 15px;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .blog-post-image img {
            width: 100%;
            display: block;
        }
        .blog-post-caption {
            text-align: center;
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 40px;
            font-style: italic;
        }

        .blog-post-content {
            max-width: 800px;
            margin: 0 auto;
            font-size: 18px;
            line-height: 1.8;
            color: var(--text-primary);
            transition: color 0.5s ease;
        }

        .blog-post-content h2 {
            font-size: 32px;
            margin: 40px 0 20px;
            border-bottom: 2px solid var(--accent-muted);
            padding-bottom: 10px;
        }

        .blog-post-content h3 {
            font-size: 26px;
            margin: 30px 0 15px;
        }
         .blog-post-content h4 { /* For sub-sub-headings like filenames */
            font-size: 20px;
            margin: 25px 0 10px;
            color: var(--text-secondary);
            font-weight: 600;
        }


        .blog-post-content p {
            margin-bottom: 25px;
        }

        .blog-post-content ul,
        .blog-post-content ol {
            padding-left: 30px;
            margin-bottom: 25px;
        }

        .blog-post-content li {
            margin-bottom: 10px;
        }

        .blog-post-content a {
            color: var(--accent-color);
            text-decoration: none;
            transition: color 0.3s;
        }

        .blog-post-content a:hover {
            color: var(--accent-hover);
        }

        .blog-post-content blockquote {
            border-left: 5px solid var(--accent-color);
            padding: 15px 20px;
            margin: 30px 0;
            background-color: var(--bg-accent);
            border-radius: 5px;
            font-style: italic;
            color: var(--text-secondary);
            transition: background-color 0.5s ease, color 0.5s ease, border-color 0.5s ease;
        }

        /* Code Block Styling */
        .blog-post-content pre {
            background-color: var(--code-bg); /* Use theme-specific bg for code */
            border: 1px solid var(--card-border);
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto; /* Enables horizontal scroll */
            margin: 30px 0;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 15px;
            line-height: 1.6;
            white-space: pre; /* Preserves whitespace and formatting */
            box-shadow: var(--shadow-sm);
            transition: background-color 0.5s ease, border-color 0.5s ease, box-shadow 0.5s ease;
        }

        .blog-post-content pre code {
            font-family: inherit;
            color: var(--text-primary); /* Code text color */
            background: none;
            padding: 0;
            font-size: inherit;
            white-space: pre; /* Ensure pre-wrap is not inherited if set on code */
        }
        /* Inline code styling */
        .blog-post-content p > code,
        .blog-post-content li > code,
        .blog-post-content h3 > code,
        .blog-post-content h4 > code {
            background-color: var(--accent-muted);
            color: var(--accent-color);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-size: 0.85em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
        }


         /*Mobile Menu */
         .mobile-menu-btn {
            display: none;
            flex-direction: column;
            justify-content: space-between;
            width: 30px;
            height: 20px;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            margin-left: 20px;
        }

        .mobile-menu-btn span {
            height: 2px;
            width: 100%;
            background-color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .mobile-menu {
            position: fixed;
            top: 80px; /* Adjust based on header height */
            left: 0;
            width: 100%;
            height: 0;
            background-color: var(--bg-secondary);
            overflow: hidden;
            transition: height 0.3s ease, opacity 0.3s ease;
            z-index: 99;
            opacity: 0;
            border-bottom: 1px solid transparent; /* Add border for transition */
        }

        .mobile-menu.active {
            height: auto; /* Or a max-height if preferred */
            opacity: 1;
            box-shadow: var(--shadow-md);
            border-bottom-color: var(--card-border);
        }


        .mobile-menu ul {
            list-style: none;
            padding: 20px;
        }

        .mobile-menu li {
            margin: 15px 0;
        }

        .mobile-menu a {
            font-size: 18px;
            color: var(--text-primary);
            text-decoration: none;
            transition: color 0.3s;
            display: block;
            padding: 10px 0;
        }

        .mobile-menu a:hover {
            color: var(--accent-color);
        }

        @media (max-width: 768px) {
            .mobile-menu-btn {
                display: flex;
            }
             .nav-links { /* Hide desktop nav links on mobile */
                display: none;
            }
             .theme-switch-wrapper { /* Adjust theme switch position or hide on very small screens if needed */
                margin-left: auto; /* Push to right if mobile menu button is also present */
             }
        }

        /* Footer */
        footer {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            padding: 80px 0 40px;
            transition: background-color 0.5s ease, color 0.5s ease;
            border-top: 1px solid var(--footer-divider); /* Added top border */
        }

        .footer-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 50px;
            flex-wrap: wrap; /* Allow wrapping */
        }

        .footer-logo {
            flex: 1 1 300px; /* Flex basis for responsiveness */
            margin-right: 20px; /* Spacing */
            margin-bottom: 30px;
        }

        .footer-logo h3 {
            font-size: 28px;
            margin-bottom: 20px;
            color: var(--text-primary);
            transition: color 0.5s ease;
        }

        .footer-logo p {
            color: var(--text-secondary);
            margin-bottom: 25px;
            font-size: 15px;
            transition: color 0.5s ease;
        }

        .footer-links {
            flex: 1 1 180px; /* Flex basis for responsiveness */
            margin-bottom: 30px; /* Spacing for wrapped items */
        }

        .footer-links h4 {
            font-size: 20px;
            margin-bottom: 25px;
            position: relative;
            padding-bottom: 12px;
            color: var(--text-primary);
            transition: color 0.5s ease;
        }

        .footer-links h4::after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            width: 50px;
            height: 3px;
            background-color: var(--accent-color);
        }

        .footer-links ul {
            list-style: none;
        }

        .footer-links li {
            margin-bottom: 12px;
        }

        .footer-links a {
            color: var(--text-secondary);
            text-decoration: none;
            transition: color 0.3s;
        }

        .footer-links a:hover {
            color: var(--accent-color);
        }

        .footer-divider {
            height: 1px;
            background-color: var(--footer-divider);
            margin: 20px 0;
            transition: background-color 0.5s ease;
        }

        .footer-bottom {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping for bottom items */
        }

        .copyright {
            color: var(--text-secondary);
            font-size: 14px;
            transition: color 0.5s ease;
            margin-bottom: 10px; /* Spacing when wrapped */
        }

        .footer-social {
            display: flex;
            gap: 15px;
        }

        .footer-social a {
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--bg-accent);
            border-radius: 50%;
            border: var(--card-border);
            color: var(--text-secondary);
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .footer-social a:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--accent-color);
            border-radius: 50%;
            transform: scale(0);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 1; /* Ensure it's above icon if icon not z-indexed */
        }

        .footer-social a:hover {
            color: white;
            transform: translateY(-3px);
            box-shadow: var(--shadow-glow);
            border-color: var(--accent-color);
        }

        .footer-social a:hover:before {
            transform: scale(1);
        }

        .footer-social a i {
            position: relative;
            z-index: 2; /* Ensure icon is above the :before pseudo-element */
        }
         /* Back to top button */
         .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--accent-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow-md);
            transition: all 0.3s, opacity 0.5s, transform 0.5s;
            z-index: 99;
            opacity: 0;
            transform: translateY(20px);
        }

        .back-to-top.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .back-to-top:hover {
            background-color: var(--accent-hover);
            transform: translateY(-5px) scale(1.05);
            box-shadow: var(--shadow-glow);
        }
         /* Theme transition overlay */
         .theme-transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-primary); /* Will be current theme's bg */
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease; /* Faster transition */
        }
         /* Custom scrollbar */
         ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 6px;
            border: 3px solid var(--scrollbar-track);
            transition: background-color 0.5s ease;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-color);
        }

        /* Prefers color scheme media query - Fallback if JS is disabled or no explicit theme is set */
        @media (prefers-color-scheme: dark) {
            body:not([data-theme="light"]):not([data-theme-forced="light"]) { /* Apply if not explicitly light */
                --bg-primary: #0f0f0f;
                --bg-secondary: #161616;
                --bg-accent: #1e1e1e;
                --text-primary: #f8f8f8;
                --text-secondary: #bebebe;
                --shadow-glow: 0 0 15px rgba(110, 86, 207, 0.4);
                --card-border: 1px solid #2a2a2a;
                --neon-glow: 0 0 10px rgba(110, 86, 207, 0.5), 0 0 20px rgba(110, 86, 207, 0.3);
                --header-bg: rgba(15, 15, 15, 0.9);
                --switch-bg: #333333;
                --switch-thumb: #6e56cf; /* Thumb color in dark mode when switch is "on" (dark selected) */
                --switch-icon-color: #ffffff;
                --footer-divider: #2a2a2a;
                --scrollbar-track: #161616;
                --scrollbar-thumb: #333333;
                --code-bg: #232323;
            }
        }

         /* Responsive Design */
         @media (max-width: 992px) {
            .footer-content {
                gap: 30px; /* Adjust gap for better layout */
            }
         }

        @media (max-width: 768px) {
            .footer-bottom {
                flex-direction: column;
                gap: 20px;
                align-items: center; /* Center items when stacked */
            }
            .blog-post-title {
                font-size: 36px;
            }
            .blog-post-content h2 {
                font-size: 28px;
            }
            .blog-post-content h3 {
                font-size: 22px;
            }
        }
        @media (max-width: 576px) {
            .blog-post-meta span {
                margin: 5px 10px; /* Further reduce margin on very small screens */
            }
            .blog-post-title {
                font-size: 30px;
            }
        }
    </style>
</head>
<body data-theme="light"> <!-- Default to light, JS will handle stored preference -->

    <!-- Theme transition overlay -->
    <div class="theme-transition-overlay" id="themeOverlay"></div>

    <!-- Header -->
    <header>
        <div class="container">
            <nav>
                <a href="/" class="logo">Samir Adhikari</a>
                <ul class="nav-links">
                    <li><a href="/">Home</a></li>
                    <li><a href="/blog.html">Blog</a></li>
                </ul>
                <!-- Theme Switch (Commented out as per your example) -->
              
                <!-- Mobile Menu Button -->
                <button class="mobile-menu-btn" id="mobileMenuBtn" aria-label="Toggle menu" aria-expanded="false">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </nav>
        </div>
    </header>

    <!-- Mobile Menu -->
     <div class="mobile-menu" id="mobileMenu">
        <ul>
            <li><a href="/">Home</a></li>
            <li><a href="/blog.html">Blog</a></li>
            <!-- Mobile theme switch can be added here if desired -->
        </ul>
    </div>

    <!-- Blog Post Section -->
    <section class="blog-post">
        <div class="container">
            <h1 class="blog-post-title">Developing a Secure, Scalable, Serverless OTP Service Using AWS SNS, Lambda, and DynamoDB</h1>
            <div class="blog-post-meta">
                <span><i class="far fa-calendar-alt"></i> May 13, 2025</span>
                <span><i class="far fa-user"></i> Samir Adhikari</span>
                <span><i class="far fa-clock"></i> 7 min read</span>
                <span><i class="far fa-comment"></i> 2 Comments</span>
            </div>

            <div class="blog-post-image">
                <!-- NOTE: Replace with your actual image path -->
                <img src="../img/otp generation.png" alt="OTP Service Architecture Diagram">
            </div>
            <p class="blog-post-caption">Fig: Architecture Diagram For OTP Service</p>

            <div class="blog-post-content">
                <p>In this tutorial, we will walk through how to build a serverless OTP (One-Time Password) system using AWS services, and deploy the entire infrastructure using Terraform (Infrastructure as Code). This system sends OTPs to users via SMS using Amazon SNS and verifies them using DynamoDB.</p>

                <h2>Understanding Serverless Computing</h2>
                <p>Before diving into the implementation, it's crucial to understand what serverless computing means and why it's the ideal approach for our OTP service.</p>
                
                <h3>What is Serverless?</h3>
                <p>Serverless computing represents a cloud execution model where the cloud provider dynamically manages the allocation and provisioning of servers. Despite the name, servers still exist but developers don't need to worry about them. The cloud provider handles infrastructure management, scaling, server maintenance, and capacity planning automatically.</p>
                
                <h3>Key Benefits of Serverless</h3>
                <ul>
                    <li><strong>Zero Server Management:</strong> No need to provision, maintain, or scale servers manually. AWS handles all infrastructure concerns.</li>
                    <li><strong>Automatic Scaling:</strong> Your application scales automatically based on demand from zero to thousands of requests per second.</li>
                    <li><strong>Cost Efficiency:</strong> You pay only for actual compute time consumed. When your code isn't running, you're not charged.</li>
                    <li><strong>Built-in High Availability:</strong> AWS distributes your functions across multiple availability zones automatically.</li>
                    <li><strong>Faster Time to Market:</strong> Focus on business logic instead of infrastructure, accelerating development cycles.</li>
                </ul>
                
                <h3>Why AWS Lambda for OTP Service?</h3>
                <p>AWS Lambda is particularly well-suited for an OTP service for several reasons:</p>
                <ul>
                    <li><strong>Event-Driven Architecture:</strong> Lambda functions execute in response to HTTP requests from API Gateway, making them perfect for REST APIs.</li>
                    <li><strong>Sporadic Traffic Patterns:</strong> OTP requests are typically unpredictable and intermittent. Lambda handles this efficiently without idle server costs.</li>
                    <li><strong>Millisecond Billing:</strong> You're charged only for the exact duration your code executes (rounded to the nearest millisecond), making it extremely cost-effective for short-lived operations like OTP generation.</li>
                    <li><strong>Built-in Integration:</strong> Lambda integrates seamlessly with API Gateway, DynamoDB, and SNS without additional configuration overhead.</li>
                    <li><strong>Stateless Operations:</strong> OTP generation and verification are stateless operations, which align perfectly with Lambda's execution model.</li>
                </ul>
                
                <p>In traditional server-based architectures, you'd need to maintain always-on servers that consume resources even during idle periods. With our serverless approach, AWS Lambda functions activate only when requests arrive, execute the necessary logic, and then terminate optimizing both cost and resource utilization.</p>

                <h2>Architecture Overview</h2>
                <p>We will use the following AWS services:</p>
                <ul>
                    <li><strong>API Gateway:</strong> To expose RESTful endpoints <code>/send-otp</code> and <code>/verify-otp</code>.</li>
                    <li><strong>AWS Lambda:</strong> To handle OTP generation and verification logic.</li>
                    <li><strong>Amazon DynamoDB:</strong> To store OTPs with expiration timestamps (TTL).</li>
                    <li><strong>Amazon SNS:</strong> To send OTPs as SMS to users.</li>
                    <li><strong>Terraform:</strong> To provision all infrastructure.</li>
                </ul>

                <h3>Request Flow Diagram</h3>
                <p>Understanding the complete request flow helps visualize how components interact in real-time:</p>

                <h4>Send OTP Flow</h4>
                <pre><code>┌──────────┐        ┌──────────────┐        ┌─────────────┐        ┌──────────┐        ┌─────────┐
│  Client  │───1───▶│ API Gateway  │───2───▶│   Lambda    │───3───▶│ DynamoDB │        │   SNS   │
│  (User)  │        │  /send-otp   │        │  send_otp   │        │  (Store) │        │ (SMS)   │
└──────────┘        └──────────────┘        └─────────────┘        └──────────┘        └─────────┘
     ▲                                              │                                          │
     │                                              └──────────────4──────────────────────────┘
     │                                                                                         │
     └──────────────────────────5: Success Response◀─────────────────────────────────────────┘

Flow Steps:
1. User sends POST request with phone number to /send-otp
2. API Gateway triggers send_otp Lambda function
3. Lambda generates 6-digit OTP and stores in DynamoDB with 5-min TTL
4. Lambda sends OTP via SNS to user's phone number
5. Success response returned to client</code></pre>

                <h4>Verify OTP Flow</h4>
                <pre><code>┌──────────┐        ┌──────────────┐        ┌─────────────┐        ┌──────────┐
│  Client  │───1───▶│ API Gateway  │───2───▶│   Lambda    │───3───▶│ DynamoDB │
│  (User)  │        │ /verify-otp  │        │ verify_otp  │        │  (Read)  │
└──────────┘        └──────────────┘        └─────────────┘        └──────────┘
     ▲                                              │                      │
     │                                              └──────4───────────────┘
     │                                              │
     │                                        [Validation]
     │                                        • OTP exists?
     │                                        • Not expired?
     │                                        • Matches input?
     │                                              │
     └──────────5: Verified True/False◀─────────────┘

Flow Steps:
1. User sends POST request with phone number and OTP to /verify-otp
2. API Gateway triggers verify_otp Lambda function
3. Lambda retrieves stored OTP from DynamoDB by userId
4. Lambda validates: existence, expiration time, OTP match
5. Response indicates verification success or specific failure reason</code></pre>

                <h3>Component Interaction Details</h3>
                <ul>
                    <li><strong>API Gateway:</strong> Acts as the entry point, handling HTTPS termination, request routing, and throttling</li>
                    <li><strong>Lambda Functions:</strong> Stateless execution environment that scales automatically based on incoming requests</li>
                    <li><strong>DynamoDB:</strong> NoSQL database with automatic TTL deletion for expired OTPs, providing consistent single-digit millisecond latency</li>
                    <li><strong>SNS:</strong> Reliable SMS delivery service supporting 200+ countries with automatic retry mechanisms</li>
                    <li><strong>IAM Roles:</strong> Least-privilege permissions ensuring Lambda can only access required resources</li>
                </ul>

                <h2>Prerequisites</h2>
                <ul>
                    <li>AWS Account</li>
                    <li>Terraform installed (>= 1.0.0)</li>
                    <li>AWS CLI configured</li>
                    <li>Basic knowledge of AWS services and Python</li>
                </ul>

                <h2>Project Structure</h2>
                <p>Your project should be organized as follows:</p>
<pre><code>.
├── main.tf
├── variables.tf
├── outputs.tf
├── lambda/
│   ├── send_otp.py
│   └── verify_otp.py
└── lambda.zip  (Generated from lambda/ directory)</code></pre>

                <h2>Step-by-Step Implementation</h2>

                <div class="blog-post-image">
                    <img src="../img/aws-lambda-console.png" alt="AWS Lambda Console - Accessing Lambda from AWS Management Console">
                </div>
                <p class="blog-post-caption">Accessing AWS Lambda from the AWS Management Console - Search for "Lambda" in the services search bar to navigate to the Lambda dashboard where you can create and manage your functions.</p>

                <h3>Step 1: Write Lambda Functions</h3>
                <p>Create the Python files for your Lambda functions inside the <code>lambda</code> directory.</p>
                
                <p>Our Lambda functions serve as the core business logic for the OTP service. The <code>send_otp.py</code> function generates a random 6-digit OTP, stores it in DynamoDB with an expiration timestamp, and sends it via SMS. The <code>verify_otp.py</code> function validates user-submitted OTPs against stored values and checks for expiration.</p>

                <h4><code>lambda/send_otp.py</code></h4>
                <p><strong>Function Overview:</strong> This function handles OTP generation and delivery. It receives a phone number, generates a secure random OTP, stores it with a 5-minute TTL (Time To Live) in DynamoDB, and dispatches it via Amazon SNS. The function includes comprehensive error handling for JSON parsing, missing parameters, and AWS service failures.</p>
<pre><code class="language-python">
import json
import boto3
import random
import time
import os

dynamodb = boto3.resource('dynamodb')
sns = boto3.client('sns')
# Ensure OTP_TABLE environment variable is set in Lambda configuration
table_name = os.environ.get('OTP_TABLE')
if not table_name:
    raise ValueError("Missing OTP_TABLE environment variable")
table = dynamodb.Table(table_name)

def lambda_handler(event, context):
    try:
        body = json.loads(event.get('body', '{}'))
    except json.JSONDecodeError:
        return {
            'statusCode': 400,
            'body': json.dumps({'error': 'Invalid JSON in request body'})
        }

    user_id = body.get('userId') # Phone number for SMS
    if not user_id:
        return {
            'statusCode': 400,
            'body': json.dumps({'error': 'userId (phone number) is required'})
        }

    otp = str(random.randint(100000, 999999))
    # TTL for 5 minutes (300 seconds)
    # DynamoDB TTL attribute must be a Unix epoch timestamp in seconds
    ttl_timestamp = int(time.time()) + 300

    try:
        table.put_item(Item={
            'userId': user_id,
            'otp': otp,
            'expirationTime': ttl_timestamp  # Ensure this matches TTL attribute in DynamoDB
        })

        sns.publish(
            PhoneNumber=user_id,
            Message=f"Your OTP is: {otp}"
        )
    except Exception as e:
        print(f"Error processing OTP: {e}") # Log error for debugging
        return {
            'statusCode': 500,
            'body': json.dumps({'error': 'Failed to send OTP', 'details': str(e)})
        }

    return {
        'statusCode': 200,
        'body': json.dumps({'message': 'OTP sent successfully'})
    }
</code></pre>

                <h4><code>lambda/verify_otp.py</code></h4>
                <p><strong>Function Overview:</strong> This function validates OTP submissions. It retrieves the stored OTP from DynamoDB using the userId, verifies it hasn't expired, compares it with the user-provided OTP, and returns appropriate success or error responses. The function implements proper HTTP status codes (404 for not found, 410 for expired, 401 for invalid) to communicate different failure scenarios clearly.</p>
<pre><code class="language-python">
import json
import boto3
import time
import os

dynamodb = boto3.resource('dynamodb')
# Ensure OTP_TABLE environment variable is set in Lambda configuration
table_name = os.environ.get('OTP_TABLE')
if not table_name:
    raise ValueError("Missing OTP_TABLE environment variable")
table = dynamodb.Table(table_name)

def lambda_handler(event, context):
    try:
        body = json.loads(event.get('body', '{}'))
    except json.JSONDecodeError:
        return {
            'statusCode': 400,
            'body': json.dumps({'verified': False, 'error': 'Invalid JSON in request body'})
        }

    user_id = body.get('userId')
    input_otp = body.get('otp')

    if not user_id or not input_otp:
        return {
            'statusCode': 400,
            'body': json.dumps({'verified': False, 'error': 'userId and otp are required'})
        }

    try:
        response = table.get_item(Key={'userId': user_id})
    except Exception as e:
        print(f"Error fetching OTP from DynamoDB: {e}")
        return {
            'statusCode': 500,
            'body': json.dumps({'verified': False, 'error': 'Failed to retrieve OTP details', 'details': str(e)})
        }
        
    item = response.get('Item')

    if not item:
        return {
            'statusCode': 404,
            'body': json.dumps({'verified': False, 'error': 'OTP not found or already used'})
        }

    # Check if OTP has expired - DynamoDB TTL should handle deletion,
    # but this is a good safeguard if item hasn't been reaped yet.
    # 'expirationTime' is expected to be a Unix epoch timestamp in seconds.
    if int(time.time()) > item.get('expirationTime', 0):
        # Optionally, delete the expired item here if not relying solely on TTL
        # table.delete_item(Key={'userId': user_id})
        return {
            'statusCode': 410, # HTTP 410 Gone
            'body': json.dumps({'verified': False, 'error': 'OTP expired'})
        }

    if item.get('otp') == input_otp:
        # Optionally, delete the OTP item after successful verification
        # to prevent reuse, if not relying on TTL for cleanup.
        # table.delete_item(Key={'userId': user_id})
        return {
            'statusCode': 200,
            'body': json.dumps({'verified': True, 'message': 'OTP verified successfully'})
        }

    return {
        'statusCode': 401, # HTTP 401 Unauthorized
        'body': json.dumps({'verified': False, 'error': 'Invalid OTP'})
    }
</code></pre>

                <div class="blog-post-image">
                    <img src="../img/lambda-function-editor.png" alt="AWS Lambda Function Editor showing send_otp.py and verify_otp.py">
                </div>
                <p class="blog-post-caption">Lambda functions deployed in AWS Console - The Code tab shows both send_otp.py and verify_otp.py files in the Lambda function editor, confirming successful deployment of our OTP service functions.</p>

                <h3>Step 2: Terraform Configuration</h3>
                <p>Create the following Terraform files in the root of your project.</p>
                
                <p>Terraform allows us to define our entire infrastructure as code, making it reproducible, version-controlled, and easy to audit. The configuration provisions all necessary AWS resources including DynamoDB tables, Lambda functions, IAM roles with least-privilege permissions, API Gateway endpoints, and the necessary integrations between services.</p>

                <h4><code>main.tf</code></h4>
                <p>This file sets up all the AWS resources including the required IAM roles and permissions. Notice how we use <code>random_id</code> to generate unique resource names, preventing conflicts if you deploy multiple environments. The IAM policies follow the principle of least privilege, granting only the specific permissions each Lambda function needs.</p>
<pre><code class="language-hcl">
provider "aws" {
  region = var.aws_region
}

# --- DynamoDB Table for OTPs ---
resource "aws_dynamodb_table" "otp_table" {
  name         = "OTPsTable-${random_id.suffix.hex}" # Unique table name
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "userId" # Primary key

  attribute {
    name = "userId" # Phone number or user identifier
    type = "S"      # String
  }

  # TTL (Time To Live) configuration to automatically delete expired OTPs
  ttl {
    attribute_name = "expirationTime" # Must match the attribute name in Lambda
    enabled        = true
  }

  tags = {
    Name        = "OTPStorageTable"
    Environment = "Production" # Or your environment
  }
}

# Generate a random suffix for unique resource naming
resource "random_id" "suffix" {
  byte_length = 4
}

# --- IAM Role and Policies for Lambda ---
resource "aws_iam_role" "lambda_exec_role" {
  name = "otp_lambda_exec_role-${random_id.suffix.hex}"

  assume_role_policy = jsonencode({
    Version = "2012-10-17",
    Statement = [{
      Action    = "sts:AssumeRole",
      Effect    = "Allow",
      Principal = { Service = "lambda.amazonaws.com" }
    }]
  })

  tags = {
    Name = "OTP Lambda Execution Role"
  }
}

# Basic Lambda execution policy (CloudWatch Logs)
resource "aws_iam_role_policy_attachment" "lambda_basic_exec_policy" {
  role       = aws_iam_role.lambda_exec_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
}

# Custom IAM policy for DynamoDB and SNS access
resource "aws_iam_policy" "lambda_custom_permissions_policy" {
  name        = "otp_lambda_permissions_policy-${random_id.suffix.hex}"
  description = "Policy for Lambda to access DynamoDB OTP table and publish to SNS"

  policy = jsonencode({
    Version = "2012-10-17",
    Statement = [
      {
        Effect   = "Allow",
        Action   = [
            "dynamodb:GetItem",
            "dynamodb:PutItem",
            "dynamodb:DeleteItem", # If you implement OTP deletion after verification
            "dynamodb:UpdateItem"  # If you need to update items
        ],
        Resource = aws_dynamodb_table.otp_table.arn
      },
      {
        Effect   = "Allow",
        Action   = ["sns:Publish"],
        Resource = "*" # Restrict this to specific SNS topics in production if possible
      }
    ]
  })
}

resource "aws_iam_role_policy_attachment" "lambda_custom_permissions_attachment" {
  role       = aws_iam_role.lambda_exec_role.name
  policy_arn = aws_iam_policy.lambda_custom_permissions_policy.arn
}

# --- Lambda Functions ---
# Package the lambda functions
data "archive_file" "lambda_zip" {
  type        = "zip"
  source_dir  = "${path.module}/lambda/"
  output_path = "${path.module}/lambda.zip"
}

resource "aws_lambda_function" "send_otp_lambda" {
  filename         = data.archive_file.lambda_zip.output_path
  function_name    = "sendOTPFunction-${random_id.suffix.hex}"
  role             = aws_iam_role.lambda_exec_role.arn
  handler          = "send_otp.lambda_handler" # Corresponds to filename.function_name
  runtime          = "python3.12"
  source_code_hash = data.archive_file.lambda_zip.output_base64sha256

  environment {
    variables = {
      OTP_TABLE = aws_dynamodb_table.otp_table.name
    }
  }

  tags = {
    Name = "SendOTP Lambda"
  }
}

resource "aws_lambda_function" "verify_otp_lambda" {
  filename         = data.archive_file.lambda_zip.output_path
  function_name    = "verifyOTPFunction-${random_id.suffix.hex}"
  role             = aws_iam_role.lambda_exec_role.arn
  handler          = "verify_otp.lambda_handler" # Corresponds to filename.function_name
  runtime          = "python3.12"
  source_code_hash = data.archive_file.lambda_zip.output_base64sha256

  environment {
    variables = {
      OTP_TABLE = aws_dynamodb_table.otp_table.name
    }
  }

  tags = {
    Name = "VerifyOTP Lambda"
  }
}

# --- API Gateway (HTTP API v2) ---
resource "aws_apigatewayv2_api" "otp_api" {
  name          = "OTPApi-${random_id.suffix.hex}"
  protocol_type = "HTTP"
  description   = "API Gateway for Serverless OTP Service"

  tags = {
    Name = "OTP Service API"
  }
}

resource "aws_apigatewayv2_stage" "default_stage" {
  api_id      = aws_apigatewayv2_api.otp_api.id
  name        = "$default" # Default stage
  auto_deploy = true      # Automatically deploy changes

  tags = {
    Name = "OTP API Default Stage"
  }
}

# API Gateway Integrations with Lambda
resource "aws_apigatewayv2_integration" "send_otp_integration" {
  api_id           = aws_apigatewayv2_api.otp_api.id
  integration_type = "AWS_PROXY" # For Lambda proxy integration
  integration_uri  = aws_lambda_function.send_otp_lambda.invoke_arn
  payload_format_version = "2.0" # For HTTP APIs
}

resource "aws_apigatewayv2_integration" "verify_otp_integration" {
  api_id           = aws_apigatewayv2_api.otp_api.id
  integration_type = "AWS_PROXY"
  integration_uri  = aws_lambda_function.verify_otp_lambda.invoke_arn
  payload_format_version = "2.0"
}

# API Gateway Routes
resource "aws_apigatewayv2_route" "send_otp_route" {
  api_id    = aws_apigatewayv2_api.otp_api.id
  route_key = "POST /send-otp" # Method and path
  target    = "integrations/${aws_apigatewayv2_integration.send_otp_integration.id}"
}

resource "aws_apigatewayv2_route" "verify_otp_route" {
  api_id    = aws_apigatewayv2_api.otp_api.id
  route_key = "POST /verify-otp"
  target    = "integrations/${aws_apigatewayv2_integration.verify_otp_integration.id}"
}

# Permissions for API Gateway to invoke Lambda functions
resource "aws_lambda_permission" "api_gw_send_otp_permission" {
  statement_id  = "AllowAPIGatewayInvokeSendOTP"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.send_otp_lambda.function_name
  principal     = "apigateway.amazonaws.com"
  # Source ARN restricts which API Gateway can invoke this Lambda
  source_arn    = "${aws_apigatewayv2_api.otp_api.execution_arn}/*/*"
}

resource "aws_lambda_permission" "api_gw_verify_otp_permission" {
  statement_id  = "AllowAPIGatewayInvokeVerifyOTP"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.verify_otp_lambda.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "${aws_apigatewayv2_api.otp_api.execution_arn}/*/*"
}

</code></pre>

                <h4><code>variables.tf</code></h4>
<pre><code class="language-hcl">
variable "aws_region" {
  description = "The AWS region to deploy resources into."
  type        = string
  default     = "us-east-1"
}
</code></pre>

                <h4><code>outputs.tf</code></h4>
<pre><code class="language-hcl">
output "api_endpoint" {
  description = "The base URL endpoint for the OTP API."
  value       = aws_apigatewayv2_api.otp_api.api_endpoint
}

output "send_otp_endpoint" {
  description = "Full URL to the /send-otp endpoint."
  value       = "${aws_apigatewayv2_api.otp_api.api_endpoint}/send-otp"
}

output "verify_otp_endpoint" {
  description = "Full URL to the /verify-otp endpoint."
  value       = "${aws_apigatewayv2_api.otp_api.api_endpoint}/verify-otp"
}

output "otp_table_name" {
  description = "Name of the DynamoDB table used for storing OTPs."
  value       = aws_dynamodb_table.otp_table.name
}
</code></pre>

                <h3>Step 3: Deploy the Stack</h3>
                <p>Before deploying, ensure your Lambda function code is in the <code>lambda</code> directory. The Terraform configuration uses <code>data "archive_file"</code> to zip this directory automatically.</p>
                <ol>
                    <li>
                        <strong>Initialize Terraform:</strong>
                        <p>Run this command in the root directory of your project (where your <code>.tf</code> files are):</p>
                        <pre><code>terraform init</code></pre>
                    </li>
                    <li>
                        <strong>Plan the deployment:</strong>
                        <p>This will show you what resources Terraform will create.</p>
                        <pre><code>terraform plan</code></pre>
                    </li>
                    <li>
                        <strong>Apply Terraform configuration:</strong>
                        <p>This will provision the resources in your AWS account. Confirm by typing <code>yes</code> when prompted.</p>
                        <pre><code>terraform apply</code></pre>
                    </li>
                </ol>
                <p>After deployment, Terraform will output the API endpoint URLs. You can now make POST requests to:</p>
                <ul>
                    <li><code>https://<api-id>.execute-api.<region>.amazonaws.com/send-otp</code>
                        <br>Request Body: <code>{ "userId": "+11234567890" }</code> (use an E.164 formatted phone number)
                    </li>
                    <li><code>https://<api-id>.execute-api.<region>.amazonaws.com/verify-otp</code>
                        <br>Request Body: <code>{ "userId": "+11234567890", "otp": "123456" }</code>
                    </li>
                </ul>
                 <p>To clean up and remove all created resources, run:</p>
                 <pre><code>terraform destroy</code></pre>

                <h2>Testing and Validation</h2>
                <p>Proper testing ensures your OTP service functions correctly before production deployment. Here are multiple approaches to test your endpoints:</p>
                
                <h3>Using cURL (Command Line)</h3>
                <p>After deploying with Terraform, you'll receive API endpoint URLs in the output. Use these URLs to test with cURL:</p>
                
                <h4>1. Send OTP Request</h4>
                <pre><code>curl -X POST https://your-api-id.execute-api.us-east-1.amazonaws.com/send-otp \<br/>  -H "Content-Type: application/json" \<br/>  -d '{"userId": "+11234567890"}'</code></pre>
                <p><strong>Expected Response:</strong></p>
                <pre><code>{"message": "OTP sent successfully"}</code></pre>
                <p>You should receive an SMS with a 6-digit OTP on the provided phone number.</p>
                
                <h4>2. Verify OTP Request</h4>
                <pre><code>curl -X POST https://your-api-id.execute-api.us-east-1.amazonaws.com/verify-otp \<br/>  -H "Content-Type: application/json" \<br/>  -d '{"userId": "+11234567890", "otp": "123456"}'</code></pre>
                <p><strong>Expected Response (Valid OTP):</strong></p>
                <pre><code>{"verified": true, "message": "OTP verified successfully"}</code></pre>
                <p><strong>Expected Response (Invalid OTP):</strong></p>
                <pre><code>{"verified": false, "error": "Invalid OTP"}</code></pre>
                
                <h3>Using Postman (GUI Tool)</h3>
                <p>Postman provides a more user-friendly interface for API testing:</p>
                <ol>
                    <li>Create a new POST request in Postman</li>
                    <li>Set the URL to your <code>/send-otp</code> endpoint</li>
                    <li>Navigate to the "Body" tab and select "raw" with "JSON" format</li>
                    <li>Enter the request body: <code>{"userId": "+11234567890"}</code></li>
                    <li>Click "Send" and observe the response</li>
                    <li>Repeat the process for <code>/verify-otp</code> endpoint with the received OTP</li>
                </ol>
                
                <h3>Testing Edge Cases</h3>
                <p>Comprehensive testing should cover various scenarios:</p>
                <ul>
                    <li><strong>Invalid Phone Format:</strong> Test with incorrectly formatted phone numbers to ensure proper error messages</li>
                    <li><strong>Expired OTP:</strong> Wait 5 minutes after generating an OTP, then attempt verification (should fail with "OTP expired")</li>
                    <li><strong>Missing Parameters:</strong> Send requests without required fields to verify error handling</li>
                    <li><strong>Invalid JSON:</strong> Send malformed JSON to test parsing error responses</li>
                    <li><strong>Non-Existent User:</strong> Try verifying an OTP for a userId that never requested one</li>
                </ul>
                
                <h3>Monitoring Test Results</h3>
                <p>Check AWS CloudWatch Logs to verify Lambda executions:</p>
                <pre><code>aws logs tail /aws/lambda/sendOTPFunction-XXXX --follow</code></pre>
                <p>This command streams real-time logs, helping you debug any issues during testing.</p>

                <h2>Error Handling and Best Practices</h2>
                <p>Building production-ready serverless applications requires careful attention to error handling, performance optimization, and security. Here are essential considerations:</p>
                
                <h3>Comprehensive Error Handling</h3>
                
                <h4>1. Lambda Function Error Patterns</h4>
                <p>Our implementation includes multiple layers of error handling:</p>
                <ul>
                    <li><strong>Input Validation:</strong> Always validate incoming data before processing. Check for required fields, proper data types, and valid formats (e.g., E.164 phone format).</li>
                    <li><strong>Try-Catch Blocks:</strong> Wrap AWS service calls in exception handlers to catch network issues, permission errors, or service throttling.</li>
                    <li><strong>Meaningful Error Messages:</strong> Return descriptive error messages that help diagnose issues without exposing sensitive system details.</li>
                    <li><strong>Appropriate HTTP Status Codes:</strong> Use semantic status codes (400 for bad requests, 401 for auth failures, 404 for not found, 500 for server errors).</li>
                </ul>
                
                <h4>2. Retry Logic and Idempotency</h4>
                <p>Implement retry mechanisms for transient failures:</p>
                <ul>
                    <li><strong>Exponential Backoff:</strong> When retrying failed operations, gradually increase wait times between attempts to avoid overwhelming downstream services.</li>
                    <li><strong>Idempotent Operations:</strong> Design functions so repeated calls with the same input produce the same result without unwanted side effects. For OTP services, consider adding a timestamp or request ID to prevent duplicate SMS sends.</li>
                    <li><strong>Dead Letter Queues (DLQ):</strong> Configure Lambda DLQs to capture failed events for later analysis or reprocessing.</li>
                </ul>
                
                <h3>Managing Cold Starts</h3>
                <p>Cold starts occur when Lambda initializes a new execution environment, causing increased latency on the first invocation. Mitigation strategies include:</p>
                <ul>
                    <li><strong>Provisioned Concurrency:</strong> Keep Lambda instances warm by configuring provisioned concurrency for predictable performance (note: this increases costs).</li>
                    <li><strong>Optimize Package Size:</strong> Reduce deployment package size by removing unnecessary dependencies. Smaller packages reduce initialization time.</li>
                    <li><strong>Code Optimization:</strong> Move initialization code outside the handler function so it runs once per container rather than per invocation.</li>
                    <li><strong>Connection Pooling:</strong> Reuse database and AWS SDK clients across invocations by declaring them outside the handler.</li>
                    <li><strong>Choose Appropriate Memory:</strong> Higher memory allocation also provides more CPU, which can reduce initialization time.</li>
                </ul>
                
                <p><strong>Example of optimized Lambda structure:</strong></p>
                <pre><code># Initialize clients outside handler (runs once per container)<br/>dynamodb = boto3.resource('dynamodb')<br/>sns = boto3.client('sns')<br/>table = dynamodb.Table(os.environ['OTP_TABLE'])<br/><br/>def lambda_handler(event, context):<br/>    # Handler logic here - reuses initialized clients</code></pre>
                
                <h3>Security Best Practices</h3>
                
                <h4>1. IAM Policies - Principle of Least Privilege</h4>
                <p>Grant only the minimum permissions necessary:</p>
                <ul>
                    <li><strong>Resource-Specific Policies:</strong> Our Terraform configuration restricts DynamoDB access to only the OTP table ARN, not all tables.</li>
                    <li><strong>Action-Specific Permissions:</strong> Allow only required actions (GetItem, PutItem) rather than broad wildcards like <code>dynamodb:*</code>.</li>
                    <li><strong>SNS Restrictions:</strong> In production, restrict SNS publish to specific topics or phone number patterns instead of <code>Resource: "*"</code>.</li>
                </ul>
                
                <h4>2. API Security</h4>
                <p>Enhance API Gateway security:</p>
                <ul>
                    <li><strong>API Keys:</strong> Require API keys for all requests to prevent unauthorized access.</li>
                    <li><strong>Usage Plans and Throttling:</strong> Configure rate limits to prevent abuse (e.g., 10 requests per minute per user).</li>
                    <li><strong>AWS WAF Integration:</strong> Add AWS Web Application Firewall to protect against common attacks like SQL injection or DDoS.</li>
                    <li><strong>Request Validation:</strong> Enable API Gateway request validation to reject malformed requests before they reach Lambda.</li>
                    <li><strong>CORS Configuration:</strong> If building a web frontend, configure CORS properly to allow only trusted domains.</li>
                </ul>
                
                <h4>3. Data Protection</h4>
                <ul>
                    <li><strong>Encryption at Rest:</strong> Enable DynamoDB encryption to protect stored OTPs (AWS manages keys automatically).</li>
                    <li><strong>Encryption in Transit:</strong> API Gateway enforces HTTPS by default, ensuring data is encrypted during transmission.</li>
                    <li><strong>Short TTL Values:</strong> Keep OTP expiration times short (5 minutes or less) to minimize exposure windows.</li>
                    <li><strong>Secure OTP Generation:</strong> Use cryptographically secure random number generators. Python's <code>random.SystemRandom()</code> is more secure than <code>random.randint()</code> for production.</li>
                </ul>
                
                <h3>Logging and Debugging</h3>
                
                <h4>CloudWatch Integration</h4>
                <p>Lambda automatically sends logs to CloudWatch. Enhance observability with these practices:</p>
                <ul>
                    <li><strong>Structured Logging:</strong> Log events in JSON format for easier parsing and querying.</li>
                    <li><strong>Contextual Information:</strong> Include request IDs, user IDs, and timestamps in log entries for correlation.</li>
                    <li><strong>Log Levels:</strong> Use appropriate levels (INFO, WARNING, ERROR) to filter logs effectively.</li>
                    <li><strong>Avoid Logging Sensitive Data:</strong> Never log OTPs, phone numbers, or other PII in production environments.</li>
                </ul>
                
                <p><strong>Example structured logging:</strong></p>
                <pre><code>import json<br/>import logging<br/><br/>logger = logging.getLogger()<br/>logger.setLevel(logging.INFO)<br/><br/>def lambda_handler(event, context):<br/>    logger.info(json.dumps({<br/>        'event': 'otp_generation',<br/>        'request_id': context.request_id,<br/>        'status': 'started'<br/>    }))</code></pre>
                
                <h4>AWS X-Ray for Distributed Tracing</h4>
                <p>Enable AWS X-Ray to trace requests across services:</p>
                <ul>
                    <li><strong>End-to-End Visibility:</strong> Track requests from API Gateway through Lambda to DynamoDB and SNS.</li>
                    <li><strong>Performance Bottlenecks:</strong> Identify slow operations and optimize accordingly.</li>
                    <li><strong>Error Analysis:</strong> Visualize where errors occur in the request chain.</li>
                </ul>
                
                <p>Enable X-Ray in Terraform by adding to Lambda configuration:</p>
                <pre><code>tracing_config {<br/>  mode = "Active"<br/>}</code></pre>
                
                <h3>Cost Optimization</h3>
                <ul>
                    <li><strong>Right-Size Memory:</strong> Lambda memory affects pricing. Start with 128MB and increase only if needed based on performance testing.</li>
                    <li><strong>Monitor Invocations:</strong> Use CloudWatch metrics to track invocation counts and identify unexpected usage spikes.</li>
                    <li><strong>DynamoDB On-Demand vs Provisioned:</strong> For unpredictable workloads, on-demand pricing (used in our setup) is often more cost-effective.</li>
                    <li><strong>SNS Cost Management:</strong> SMS costs vary by country. Monitor SNS spending and implement rate limiting to prevent abuse.</li>
                    <li><strong>Set Budget Alerts:</strong> Configure AWS Budgets to alert you when spending exceeds thresholds.</li>
                </ul>
                
                <h3>Production Readiness Checklist</h3>
                <p>Before deploying to production, ensure you've addressed:</p>
                <ul>
                    <li>✓ Implemented proper error handling and retry logic</li>
                    <li>✓ Configured CloudWatch alarms for errors and throttling</li>
                    <li>✓ Enabled AWS X-Ray for distributed tracing</li>
                    <li>✓ Applied least-privilege IAM policies</li>
                    <li>✓ Set up API rate limiting and throttling</li>
                    <li>✓ Enabled DynamoDB Point-in-Time Recovery for disaster recovery</li>
                    <li>✓ Configured Lambda reserved concurrency to prevent runaway costs</li>
                    <li>✓ Tested all error scenarios (expired OTPs, invalid inputs, network failures)</li>
                    <li>✓ Set up monitoring dashboards and alerts</li>
                    <li>✓ Documented API endpoints and error codes</li>
                    <li>✓ Performed load testing to validate auto-scaling behavior</li>
                </ul>

                <h2>Security Concerns and Advanced Best Practices</h2>
                
                <p>Building a production OTP service requires addressing critical security and cost concerns that can significantly impact your application's reliability and budget.</p>

                <h3>SMS Cost Management and Prevention</h3>
                
                <p>SMS delivery through Amazon SNS incurs charges that vary significantly by destination country. Without proper controls, malicious actors or bugs can generate unexpected costs.</p>

                <h4>SMS Pricing Reality Check</h4>
                <ul>
                    <li><strong>United States:</strong> $0.00645 per SMS (relatively inexpensive)</li>
                    <li><strong>India:</strong> $0.00425 per SMS</li>
                    <li><strong>United Kingdom:</strong> $0.04290 per SMS (10x more expensive)</li>
                    <li><strong>Germany:</strong> $0.07240 per SMS</li>
                    <li><strong>Kuwait:</strong> $0.11550 per SMS (27x US cost)</li>
                </ul>

                <p><strong>Cost Scenario:</strong> If an attacker triggers 10,000 SMS messages to Kuwait numbers, your bill would be $1,155—in just minutes.</p>

                <h4>Implementing Rate Limiting</h4>
                <p>Add DynamoDB tracking to prevent SMS abuse:</p>

                <pre><code>import time

def lambda_handler(event, context):
    body = json.loads(event.get('body', '{}'))
    user_id = body.get('userId')
    
    # Check rate limit: max 3 OTPs per phone number per hour
    rate_limit_key = f"rate_limit_{user_id}"
    
    try:
        response = table.get_item(Key={'userId': rate_limit_key})
        item = response.get('Item')
        
        if item:
            attempts = item.get('attempts', 0)
            last_reset = item.get('last_reset', 0)
            current_time = int(time.time())
            
            # Reset counter every hour
            if current_time - last_reset > 3600:
                attempts = 0
                last_reset = current_time
            
            if attempts >= 3:
                return {
                    'statusCode': 429,  # Too Many Requests
                    'body': json.dumps({
                        'error': 'Rate limit exceeded',
                        'message': 'Maximum 3 OTP requests per hour',
                        'retry_after': 3600 - (current_time - last_reset)
                    })
                }
            
            # Increment attempt counter
            table.put_item(Item={
                'userId': rate_limit_key,
                'attempts': attempts + 1,
                'last_reset': last_reset,
                'expirationTime': current_time + 3600
            })
        else:
            # First attempt
            table.put_item(Item={
                'userId': rate_limit_key,
                'attempts': 1,
                'last_reset': int(time.time()),
                'expirationTime': int(time.time()) + 3600
            })
    
    except Exception as e:
        print(f"Rate limiting error: {e}")
        # Fail closed - deny request if rate limiting fails
        return {
            'statusCode': 503,
            'body': json.dumps({'error': 'Service temporarily unavailable'})
        }
    
    # Continue with normal OTP generation
    otp = str(random.randint(100000, 999999))
    # ... rest of the code</code></pre>

                <h4>Geographic SMS Restrictions</h4>
                <p>Restrict SMS delivery to approved countries to manage costs:</p>

                <pre><code>import phonenumbers

ALLOWED_COUNTRY_CODES = ['US', 'IN', 'CA', 'AU']  # Define allowed countries

def validate_phone_number(phone_number):
    """Validate phone number format and country"""
    try:
        parsed = phonenumbers.parse(phone_number, None)
        
        if not phonenumbers.is_valid_number(parsed):
            return False, "Invalid phone number"
        
        country_code = phonenumbers.region_code_for_number(parsed)
        
        if country_code not in ALLOWED_COUNTRY_CODES:
            return False, f"SMS not supported for country: {country_code}"
        
        return True, None
    
    except phonenumbers.NumberParseException:
        return False, "Invalid phone number format"

def lambda_handler(event, context):
    body = json.loads(event.get('body', '{}'))
    user_id = body.get('userId')
    
    # Validate phone number and country
    is_valid, error_message = validate_phone_number(user_id)
    
    if not is_valid:
        return {
            'statusCode': 400,
            'body': json.dumps({
                'error': error_message,
                'supported_countries': ALLOWED_COUNTRY_CODES
            })
        }
    
    # Continue with OTP generation...</code></pre>

                <h4>Cost Monitoring Alarms</h4>
                <p>Set up CloudWatch billing alarms for SNS spending:</p>

                <pre><code>Resources:
  SNSCostAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: HighSNSCosts
      AlarmDescription: Alert when SNS costs exceed threshold
      MetricName: EstimatedCharges
      Namespace: AWS/Billing
      Statistic: Maximum
      Period: 21600  # 6 hours
      EvaluationPeriods: 1
      Threshold: 50.0  # Alert at $50
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: ServiceName
          Value: AmazonSNS
      AlarmActions:
        - !Ref AlertSNSTopic</code></pre>

                <h3>OTP Retry Limits and Security</h3>

                <p>Implement verification attempt limits to prevent brute-force attacks:</p>

                <h4>Track Failed Verification Attempts</h4>
                <pre><code>def lambda_handler(event, context):
    body = json.loads(event.get('body', '{}'))
    user_id = body.get('userId')
    input_otp = body.get('otp')
    
    # Track verification attempts
    attempt_key = f"verify_attempts_{user_id}"
    
    try:
        attempt_record = table.get_item(Key={'userId': attempt_key})
        
        if attempt_record.get('Item'):
            failed_attempts = attempt_record['Item'].get('failed_attempts', 0)
            
            # Lock account after 5 failed attempts
            if failed_attempts >= 5:
                return {
                    'statusCode': 403,
                    'body': json.dumps({
                        'verified': False,
                        'error': 'Account temporarily locked',
                        'message': 'Too many failed attempts. Request new OTP in 15 minutes.'
                    })
                }
    
    except Exception as e:
        print(f"Error checking attempts: {e}")
    
    # Get stored OTP
    response = table.get_item(Key={'userId': user_id})
    item = response.get('Item')
    
    if not item:
        # Increment failed attempts
        increment_failed_attempts(user_id, attempt_key)
        return {
            'statusCode': 404,
            'body': json.dumps({
                'verified': False,
                'error': 'OTP not found or expired'
            })
        }
    
    # Check expiration
    if int(time.time()) > item.get('expirationTime', 0):
        # Don't increment attempts for expired OTPs
        return {
            'statusCode': 410,
            'body': json.dumps({
                'verified': False,
                'error': 'OTP expired',
                'message': 'Request a new OTP'
            })
        }
    
    # Verify OTP
    if item.get('otp') == input_otp:
        # Success - clear attempt counter and delete OTP
        table.delete_item(Key={'userId': attempt_key})
        table.delete_item(Key={'userId': user_id})
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'verified': True,
                'message': 'OTP verified successfully'
            })
        }
    
    # Failed verification - increment counter
    increment_failed_attempts(user_id, attempt_key)
    
    return {
        'statusCode': 401,
        'body': json.dumps({
            'verified': False,
            'error': 'Invalid OTP',
            'attempts_remaining': 5 - get_failed_attempts(user_id, attempt_key)
        })
    }

def increment_failed_attempts(user_id, attempt_key):
    """Increment failed verification attempts"""
    try:
        current_attempts = get_failed_attempts(user_id, attempt_key)
        
        table.put_item(Item={
            'userId': attempt_key,
            'failed_attempts': current_attempts + 1,
            'expirationTime': int(time.time()) + 900  # 15 min lockout
        })
    except Exception as e:
        print(f"Error incrementing attempts: {e}")

def get_failed_attempts(user_id, attempt_key):
    """Get current failed attempt count"""
    try:
        response = table.get_item(Key={'userId': attempt_key})
        return response.get('Item', {}).get('failed_attempts', 0)
    except:
        return 0</code></pre>

                <h3>Additional Security Hardening</h3>

                <h4>1. OTP Complexity and Entropy</h4>
                <p>Use cryptographically secure random number generation:</p>
                <pre><code>import secrets

# Instead of: otp = str(random.randint(100000, 999999))
# Use:
otp = str(secrets.randbelow(900000) + 100000)  # Cryptographically secure</code></pre>

                <h4>2. Phone Number Validation</h4>
                <p>Prevent attacks using invalid or premium-rate numbers:</p>
                <ul>
                    <li>Validate E.164 format: +[country code][number]</li>
                    <li>Block premium-rate prefixes</li>
                    <li>Implement allowlist for trusted number ranges</li>
                    <li>Verify number isn't VoIP or disposable</li>
                </ul>

                <h4>3. Request Origin Validation</h4>
                <p>Implement CAPTCHA or challenge tokens to prevent automated abuse:</p>
                <pre><code># Verify reCAPTCHA token before sending OTP
def verify_recaptcha(token):
    """Verify Google reCAPTCHA token"""
    import requests
    
    secret_key = os.environ['RECAPTCHA_SECRET']
    
    response = requests.post(
        'https://www.google.com/recaptcha/api/siteverify',
        data={
            'secret': secret_key,
            'response': token
        }
    )
    
    result = response.json()
    return result.get('success', False) and result.get('score', 0) > 0.5</code></pre>

                <h4>4. Honeypot Fields</h4>
                <p>Add hidden fields to detect bot submissions:</p>
                <pre><code>def lambda_handler(event, context):
    body = json.loads(event.get('body', '{}'))
    
    # Check honeypot field (should be empty)
    if body.get('website') or body.get('url'):
        # Likely bot - fail silently
        return {
            'statusCode': 200,
            'body': json.dumps({'message': 'OTP sent successfully'})
        }
    
    # Continue with normal processing...</code></pre>

                <h2>Conclusion</h2>
                <p>Using Terraform, you've successfully defined and deployed a fully serverless, scalable, and secure OTP delivery system. This approach leverages AWS API Gateway for exposing endpoints, AWS Lambda for business logic, Amazon SNS for sending SMS, and Amazon DynamoDB for persistent OTP storage with automatic expiration. The entire infrastructure is managed as code, ensuring it is repeatable, version-controlled, and auditable.</p>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <h3>Samir Adhikari</h3>
                    <p>A blog dedicated to sharing AWS insights, DevOps practices, and cloud solution strategies.</p>
                </div>
                <div class="footer-links">
                    <h4>Quick Links</h4>
                    <ul>
                        <li><a href="/">Home</a></li>
                        <li><a href="/blog.html">Blog</a></li>
                    </ul>
                </div>
                <div class="footer-links">
                    <h4>Categories</h4>
                    <ul>
                        <li><a href="#">AWS</a></li>
                        <li><a href="#">DevOps</a></li>
                        <li><a href="#">Serverless</a></li>
                        <li><a href="#">Terraform</a></li>
                    </ul>
                </div>
                <div class="footer-links">
                    <h4>Contact</h4>
                    <ul>
                        <li><a href="mailto:samir.adhhh@example.com">samir.adhhh@gmail.com</a></li>
                        <li><a href="tel:+1234567890">9861762422</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-divider"></div>
            <div class="footer-bottom">
                <div class="copyright">© 2025 Samir Adhikari. All rights reserved.</div>
                <div class="footer-social">
                    <a href="#" aria-label="Facebook"><i class="fab fa-facebook-f"></i></a>
                    <a href="#" aria-label="Twitter"><i class="fab fa-twitter"></i></a>
                    <a href="#" aria-label="Instagram"><i class="fab fa-instagram"></i></a>
                    <a href="#" aria-label="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
                </div>
            </div>
        </div>
    </footer>

    <!-- Back to top button -->
    <a href="#" class="back-to-top" id="backToTopBtn" aria-label="Back to top">
        <i class="fas fa-arrow-up"></i>
    </a>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const checkbox = document.getElementById('checkbox');
            const themeOverlay = document.getElementById('themeOverlay');
            const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');

            function applyThemeTransition() {
                if (themeOverlay) {
                    themeOverlay.style.opacity = '1';
                    // Ensure display is block before starting transition
                    // but only if it's not already visible (to avoid flicker on load)
                    if (getComputedStyle(themeOverlay).display === 'none') {
                         themeOverlay.style.display = 'block';
                    }
                    setTimeout(() => {
                        themeOverlay.style.opacity = '0';
                        setTimeout(() => {
                            themeOverlay.style.display = 'none';
                        }, 300); // Match transition duration
                    }, 10); // Short delay to allow CSS to apply
                }
            }

            function setTheme(theme, manualSwitch = false) {
                applyThemeTransition();
                document.documentElement.setAttribute('data-theme', theme);
                if (manualSwitch) { // Only set forced if user manually toggled
                    document.documentElement.setAttribute('data-theme-forced', theme);
                }
                localStorage.setItem('theme', theme);
                if (checkbox) {
                    checkbox.checked = theme === 'dark';
                }
            }

            const storedTheme = localStorage.getItem('theme');
            const forcedTheme = document.documentElement.getAttribute('data-theme-forced');

            if (storedTheme) {
                setTheme(storedTheme);
            } else if (!forcedTheme && prefersDarkScheme.matches) {
                setTheme('dark');
            } else { // Default to light if nothing else set
                setTheme('light');
            }


            if (checkbox) {
                checkbox.addEventListener('change', () => {
                    const newTheme = checkbox.checked ? 'dark' : 'light';
                    setTheme(newTheme, true); // True for manual switch
                });
            }
            
            // Listen for OS theme changes if no theme explicitly set by user
            prefersDarkScheme.addEventListener('change', (e) => {
                // Only change if no theme has been manually forced by user toggle
                if (!document.documentElement.getAttribute('data-theme-forced')) {
                    setTheme(e.matches ? 'dark' : 'light');
                }
            });


             // --- Back to Top Button ---
            const backToTopBtn = document.getElementById('backToTopBtn');
            if (backToTopBtn) {
                window.addEventListener('scroll', () => {
                    if (window.pageYOffset > 300) {
                        backToTopBtn.classList.add('visible');
                    } else {
                        backToTopBtn.classList.remove('visible');
                    }
                });

                backToTopBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                });
            }

            // --- Mobile Menu ---
            const mobileMenuBtn = document.getElementById('mobileMenuBtn');
            const mobileMenu = document.getElementById('mobileMenu');

            if (mobileMenuBtn && mobileMenu) {
                mobileMenuBtn.addEventListener('click', () => {
                    const isActive = mobileMenu.classList.toggle('active');
                    mobileMenuBtn.setAttribute('aria-expanded', isActive);
                });

                // Close mobile menu when a link is clicked (optional)
                mobileMenu.querySelectorAll('a').forEach(link => {
                    link.addEventListener('click', () => {
                        mobileMenu.classList.remove('active');
                        mobileMenuBtn.setAttribute('aria-expanded', 'false');
                    });
                });
            }
        });
    </script>
</body>
</html>